"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Entity = void 0;
const ultis_1 = require("../ultis");
const lodash_clonedeep_1 = __importDefault(require("lodash.clonedeep"));
function Entity() {
    const getPrivateName = (name) => `__HIDDEN__${name}`;
    const PRIMITIVE = [Number, String, Boolean];
    const constructData = (type, value) => (PRIMITIVE.includes(type) ? type(value) : new type(value));
    return function (constructorFunction) {
        return class extends constructorFunction {
            constructor(_model, ...args) {
                const model = lodash_clonedeep_1.default(_model);
                super(model, ...args);
                const context = this;
                const data = (context['__data__'] = {});
                const metaData = (context['__meta__'] || new Map());
                Array.from(metaData.values())
                    .filter((meta) => meta.transform)
                    .map((meta) => {
                    const { propertyKey, transform } = meta;
                    model[propertyKey] = transform === null || transform === void 0 ? void 0 : transform.fn(model, propertyKey);
                });
                Array.from(metaData.values())
                    .filter((meta) => !!meta.type)
                    .map((meta) => {
                    const { propertyKey, type } = meta;
                    const descriptor = {
                        set: function (value) {
                            data[getPrivateName(propertyKey)] = ultis_1.isNil(value)
                                ? null
                                : Array.isArray(value)
                                    ? value.map((v) => constructData(type, v))
                                    : constructData(type, value);
                        },
                        get: function () {
                            return data[getPrivateName(propertyKey)];
                        },
                    };
                    Object.defineProperty(context, propertyKey, descriptor);
                });
                Object.defineProperties(this, {
                    __data__: { writable: true, enumerable: false },
                });
                Object.defineProperties(this, {
                    __meta__: { writable: true, enumerable: false },
                });
                Object.assign(context, model);
            }
        };
    };
}
exports.Entity = Entity;
